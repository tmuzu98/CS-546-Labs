(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.RouteConfig = {}));
}(this, function (exports) { 'use strict';

  var Config =
  /*#__PURE__*/
  function () {
    function Config(name) {
      if (typeof name !== 'string') {
        throw new TypeError('Config: name must be a string');
      }

      this._name = name;
    }

    var _proto = Config.prototype;

    _proto.isConfig = function isConfig() {
      return true;
    };

    _proto.merge = function merge() {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      return Object.assign.apply(Object, [{}].concat(values));
    };

    _proto.name = function name() {
      return this._name;
    };

    _proto.set = function set(value) {
      return Object.assign({}, value);
    };

    return Config;
  }();

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  /**
   * Expose `pathToRegexp`.
   */
  var pathToRegexp_1 = pathToRegexp;
  var parse_1 = parse;
  var compile_1 = compile;
  var tokensToFunction_1 = tokensToFunction;
  var tokensToRegExp_1 = tokensToRegExp;

  /**
   * Default configs.
   */
  var DEFAULT_DELIMITER = '/';

  /**
   * The main path matching regexp utility.
   *
   * @type {RegExp}
   */
  var PATH_REGEXP = new RegExp([
    // Match escaped characters that would otherwise appear in future matches.
    // This allows the user to escape special characters that won't transform.
    '(\\\\.)',
    // Match Express-style parameters and un-named parameters with a prefix
    // and optional suffixes. Matches appear as:
    //
    // ":test(\\d+)?" => ["test", "\d+", undefined, "?"]
    // "(\\d+)"  => [undefined, undefined, "\d+", undefined]
    '(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?'
  ].join('|'), 'g');

  /**
   * Parse a string for the raw tokens.
   *
   * @param  {string}  str
   * @param  {Object=} options
   * @return {!Array}
   */
  function parse (str, options) {
    var tokens = [];
    var key = 0;
    var index = 0;
    var path = '';
    var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER;
    var whitelist = (options && options.whitelist) || undefined;
    var pathEscaped = false;
    var res;

    while ((res = PATH_REGEXP.exec(str)) !== null) {
      var m = res[0];
      var escaped = res[1];
      var offset = res.index;
      path += str.slice(index, offset);
      index = offset + m.length;

      // Ignore already escaped sequences.
      if (escaped) {
        path += escaped[1];
        pathEscaped = true;
        continue
      }

      var prev = '';
      var name = res[2];
      var capture = res[3];
      var group = res[4];
      var modifier = res[5];

      if (!pathEscaped && path.length) {
        var k = path.length - 1;
        var c = path[k];
        var matches = whitelist ? whitelist.indexOf(c) > -1 : true;

        if (matches) {
          prev = c;
          path = path.slice(0, k);
        }
      }

      // Push the current path onto the tokens.
      if (path) {
        tokens.push(path);
        path = '';
        pathEscaped = false;
      }

      var repeat = modifier === '+' || modifier === '*';
      var optional = modifier === '?' || modifier === '*';
      var pattern = capture || group;
      var delimiter = prev || defaultDelimiter;

      tokens.push({
        name: name || key++,
        prefix: prev,
        delimiter: delimiter,
        optional: optional,
        repeat: repeat,
        pattern: pattern
          ? escapeGroup(pattern)
          : '[^' + escapeString(delimiter === defaultDelimiter ? delimiter : (delimiter + defaultDelimiter)) + ']+?'
      });
    }

    // Push any remaining characters.
    if (path || index < str.length) {
      tokens.push(path + str.substr(index));
    }

    return tokens
  }

  /**
   * Compile a string to a template function for the path.
   *
   * @param  {string}             str
   * @param  {Object=}            options
   * @return {!function(Object=, Object=)}
   */
  function compile (str, options) {
    return tokensToFunction(parse(str, options))
  }

  /**
   * Expose a method for transforming tokens into the path function.
   */
  function tokensToFunction (tokens) {
    // Compile all the tokens into regexps.
    var matches = new Array(tokens.length);

    // Compile all the patterns before compilation.
    for (var i = 0; i < tokens.length; i++) {
      if (typeof tokens[i] === 'object') {
        matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
      }
    }

    return function (data, options) {
      var path = '';
      var encode = (options && options.encode) || encodeURIComponent;

      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];

        if (typeof token === 'string') {
          path += token;
          continue
        }

        var value = data ? data[token.name] : undefined;
        var segment;

        if (Array.isArray(value)) {
          if (!token.repeat) {
            throw new TypeError('Expected "' + token.name + '" to not repeat, but got array')
          }

          if (value.length === 0) {
            if (token.optional) continue

            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }

          for (var j = 0; j < value.length; j++) {
            segment = encode(value[j], token);

            if (!matches[i].test(segment)) {
              throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '"')
            }

            path += (j === 0 ? token.prefix : token.delimiter) + segment;
          }

          continue
        }

        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
          segment = encode(String(value), token);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"')
          }

          path += token.prefix + segment;
          continue
        }

        if (token.optional) continue

        throw new TypeError('Expected "' + token.name + '" to be ' + (token.repeat ? 'an array' : 'a string'))
      }

      return path
    }
  }

  /**
   * Escape a regular expression string.
   *
   * @param  {string} str
   * @return {string}
   */
  function escapeString (str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1')
  }

  /**
   * Escape the capturing group by escaping special characters and meaning.
   *
   * @param  {string} group
   * @return {string}
   */
  function escapeGroup (group) {
    return group.replace(/([=!:$/()])/g, '\\$1')
  }

  /**
   * Get the flags for a regexp from the options.
   *
   * @param  {Object} options
   * @return {string}
   */
  function flags (options) {
    return options && options.sensitive ? '' : 'i'
  }

  /**
   * Pull out keys from a regexp.
   *
   * @param  {!RegExp} path
   * @param  {Array=}  keys
   * @return {!RegExp}
   */
  function regexpToRegexp (path, keys) {
    if (!keys) return path

    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);

    if (groups) {
      for (var i = 0; i < groups.length; i++) {
        keys.push({
          name: i,
          prefix: null,
          delimiter: null,
          optional: false,
          repeat: false,
          pattern: null
        });
      }
    }

    return path
  }

  /**
   * Transform an array into a regexp.
   *
   * @param  {!Array}  path
   * @param  {Array=}  keys
   * @param  {Object=} options
   * @return {!RegExp}
   */
  function arrayToRegexp (path, keys, options) {
    var parts = [];

    for (var i = 0; i < path.length; i++) {
      parts.push(pathToRegexp(path[i], keys, options).source);
    }

    return new RegExp('(?:' + parts.join('|') + ')', flags(options))
  }

  /**
   * Create a path regexp from string input.
   *
   * @param  {string}  path
   * @param  {Array=}  keys
   * @param  {Object=} options
   * @return {!RegExp}
   */
  function stringToRegexp (path, keys, options) {
    return tokensToRegExp(parse(path, options), keys, options)
  }

  /**
   * Expose a function for taking tokens and returning a RegExp.
   *
   * @param  {!Array}  tokens
   * @param  {Array=}  keys
   * @param  {Object=} options
   * @return {!RegExp}
   */
  function tokensToRegExp (tokens, keys, options) {
    options = options || {};

    var strict = options.strict;
    var start = options.start !== false;
    var end = options.end !== false;
    var delimiter = options.delimiter || DEFAULT_DELIMITER;
    var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|');
    var route = start ? '^' : '';

    // Iterate over the tokens and create our regexp string.
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        route += escapeString(token);
      } else {
        var capture = token.repeat
          ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*'
          : token.pattern;

        if (keys) keys.push(token);

        if (token.optional) {
          if (!token.prefix) {
            route += '(' + capture + ')?';
          } else {
            route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?';
          }
        } else {
          route += escapeString(token.prefix) + '(' + capture + ')';
        }
      }
    }

    if (end) {
      if (!strict) route += '(?:' + escapeString(delimiter) + ')?';

      route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';
    } else {
      var endToken = tokens[tokens.length - 1];
      var isEndDelimited = typeof endToken === 'string'
        ? endToken[endToken.length - 1] === delimiter
        : endToken === undefined;

      if (!strict) route += '(?:' + escapeString(delimiter) + '(?=' + endsWith + '))?';
      if (!isEndDelimited) route += '(?=' + escapeString(delimiter) + '|' + endsWith + ')';
    }

    return new RegExp(route, flags(options))
  }

  /**
   * Normalize the given path string, returning a regular expression.
   *
   * An empty array can be passed in for the keys, which will hold the
   * placeholder key descriptions. For example, using `/user/:id`, `keys` will
   * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
   *
   * @param  {(string|RegExp|Array)} path
   * @param  {Array=}                keys
   * @param  {Object=}               options
   * @return {!RegExp}
   */
  function pathToRegexp (path, keys, options) {
    if (path instanceof RegExp) {
      return regexpToRegexp(path, keys)
    }

    if (Array.isArray(path)) {
      return arrayToRegexp(/** @type {!Array} */ (path), keys, options)
    }

    return stringToRegexp(/** @type {string} */ (path), keys, options)
  }
  pathToRegexp_1.parse = parse_1;
  pathToRegexp_1.compile = compile_1;
  pathToRegexp_1.tokensToFunction = tokensToFunction_1;
  pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

  /**
   * Helpers to enable Immutable compatibility *without* bringing in
   * the 'immutable' package as a dependency.
   */

  /**
   * Check if an object is immutable by checking if it has a key specific
   * to the immutable library.
   *
   * @param  {any} object
   * @return {bool}
   */
  function isImmutable(object) {
    return !!(object && typeof object.hasOwnProperty === 'function' && (object.hasOwnProperty('__ownerID') || // Immutable.Map
    object._map && object._map.hasOwnProperty('__ownerID'))); // Immutable.Record
  }

  /**
   * Denormalize an immutable entity.
   *
   * @param  {Schema} schema
   * @param  {Immutable.Map|Immutable.Record} input
   * @param  {function} unvisit
   * @param  {function} getDenormalizedEntity
   * @return {Immutable.Map|Immutable.Record}
   */
  function denormalizeImmutable(schema, input, unvisit) {
    return Object.keys(schema).reduce(function (object, key) {
      // Immutable maps cast keys to strings on write so we need to ensure
      // we're accessing them using string keys.
      var stringKey = '' + key;

      if (object.has(stringKey)) {
        return object.set(stringKey, unvisit(object.get(stringKey), schema[stringKey]));
      } else {
        return object;
      }
    }, input);
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };











  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();







  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };



  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };











  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var getDefaultGetId = function getDefaultGetId(idAttribute) {
    return function (input) {
      return isImmutable(input) ? input.get(idAttribute) : input[idAttribute];
    };
  };

  var EntitySchema = function () {
    function EntitySchema(key) {
      var definition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, EntitySchema);

      if (!key || typeof key !== 'string') {
        throw new Error('Expected a string key for Entity, but found ' + key + '.');
      }

      var _options$idAttribute = options.idAttribute,
          idAttribute = _options$idAttribute === undefined ? 'id' : _options$idAttribute,
          _options$mergeStrateg = options.mergeStrategy,
          mergeStrategy = _options$mergeStrateg === undefined ? function (entityA, entityB) {
        return _extends({}, entityA, entityB);
      } : _options$mergeStrateg,
          _options$processStrat = options.processStrategy,
          processStrategy = _options$processStrat === undefined ? function (input) {
        return _extends({}, input);
      } : _options$processStrat;


      this._key = key;
      this._getId = typeof idAttribute === 'function' ? idAttribute : getDefaultGetId(idAttribute);
      this._idAttribute = idAttribute;
      this._mergeStrategy = mergeStrategy;
      this._processStrategy = processStrategy;
      this.define(definition);
    }

    EntitySchema.prototype.define = function define(definition) {
      this.schema = Object.keys(definition).reduce(function (entitySchema, key) {
        var _babelHelpers$extends;

        var schema = definition[key];
        return _extends({}, entitySchema, (_babelHelpers$extends = {}, _babelHelpers$extends[key] = schema, _babelHelpers$extends));
      }, this.schema || {});
    };

    EntitySchema.prototype.getId = function getId(input, parent, key) {
      return this._getId(input, parent, key);
    };

    EntitySchema.prototype.merge = function merge(entityA, entityB) {
      return this._mergeStrategy(entityA, entityB);
    };

    EntitySchema.prototype.normalize = function normalize(input, parent, key, visit, addEntity) {
      var _this = this;

      var processedEntity = this._processStrategy(input, parent, key);
      Object.keys(this.schema).forEach(function (key) {
        if (processedEntity.hasOwnProperty(key) && _typeof(processedEntity[key]) === 'object') {
          var schema = _this.schema[key];
          processedEntity[key] = visit(processedEntity[key], processedEntity, key, schema, addEntity);
        }
      });

      addEntity(this, processedEntity, input, parent, key);
      return this.getId(input, parent, key);
    };

    EntitySchema.prototype.denormalize = function denormalize(entity, unvisit) {
      var _this2 = this;

      if (isImmutable(entity)) {
        return denormalizeImmutable(this.schema, entity, unvisit);
      }

      Object.keys(this.schema).forEach(function (key) {
        if (entity.hasOwnProperty(key)) {
          var schema = _this2.schema[key];
          entity[key] = unvisit(entity[key], schema);
        }
      });
      return entity;
    };

    createClass(EntitySchema, [{
      key: 'key',
      get: function get$$1() {
        return this._key;
      }
    }, {
      key: 'idAttribute',
      get: function get$$1() {
        return this._idAttribute;
      }
    }]);
    return EntitySchema;
  }();

  var PolymorphicSchema = function () {
    function PolymorphicSchema(definition, schemaAttribute) {
      classCallCheck(this, PolymorphicSchema);

      if (schemaAttribute) {
        this._schemaAttribute = typeof schemaAttribute === 'string' ? function (input) {
          return input[schemaAttribute];
        } : schemaAttribute;
      }
      this.define(definition);
    }

    PolymorphicSchema.prototype.define = function define(definition) {
      this.schema = definition;
    };

    PolymorphicSchema.prototype.getSchemaAttribute = function getSchemaAttribute(input, parent, key) {
      return !this.isSingleSchema && this._schemaAttribute(input, parent, key);
    };

    PolymorphicSchema.prototype.inferSchema = function inferSchema(input, parent, key) {
      if (this.isSingleSchema) {
        return this.schema;
      }

      var attr = this.getSchemaAttribute(input, parent, key);
      return this.schema[attr];
    };

    PolymorphicSchema.prototype.normalizeValue = function normalizeValue(value, parent, key, visit, addEntity) {
      var schema = this.inferSchema(value, parent, key);
      if (!schema) {
        return value;
      }
      var normalizedValue = visit(value, parent, key, schema, addEntity);
      return this.isSingleSchema || normalizedValue === undefined || normalizedValue === null ? normalizedValue : { id: normalizedValue, schema: this.getSchemaAttribute(value, parent, key) };
    };

    PolymorphicSchema.prototype.denormalizeValue = function denormalizeValue(value, unvisit) {
      var schemaKey = isImmutable(value) ? value.get('schema') : value.schema;
      if (!this.isSingleSchema && !schemaKey) {
        return value;
      }
      var id = isImmutable(value) ? value.get('id') : value.id;
      var schema = this.isSingleSchema ? this.schema : this.schema[schemaKey];
      return unvisit(id || value, schema);
    };

    createClass(PolymorphicSchema, [{
      key: 'isSingleSchema',
      get: function get$$1() {
        return !this._schemaAttribute;
      }
    }]);
    return PolymorphicSchema;
  }();

  var UnionSchema = function (_PolymorphicSchema) {
    inherits(UnionSchema, _PolymorphicSchema);

    function UnionSchema(definition, schemaAttribute) {
      classCallCheck(this, UnionSchema);

      if (!schemaAttribute) {
        throw new Error('Expected option "schemaAttribute" not found on UnionSchema.');
      }
      return possibleConstructorReturn(this, _PolymorphicSchema.call(this, definition, schemaAttribute));
    }

    UnionSchema.prototype.normalize = function normalize(input, parent, key, visit, addEntity) {
      return this.normalizeValue(input, parent, key, visit, addEntity);
    };

    UnionSchema.prototype.denormalize = function denormalize(input, unvisit) {
      return this.denormalizeValue(input, unvisit);
    };

    return UnionSchema;
  }(PolymorphicSchema);

  var ValuesSchema = function (_PolymorphicSchema) {
    inherits(ValuesSchema, _PolymorphicSchema);

    function ValuesSchema() {
      classCallCheck(this, ValuesSchema);
      return possibleConstructorReturn(this, _PolymorphicSchema.apply(this, arguments));
    }

    ValuesSchema.prototype.normalize = function normalize(input, parent, key, visit, addEntity) {
      var _this2 = this;

      return Object.keys(input).reduce(function (output, key, index) {
        var _babelHelpers$extends;

        var value = input[key];
        return value !== undefined && value !== null ? _extends({}, output, (_babelHelpers$extends = {}, _babelHelpers$extends[key] = _this2.normalizeValue(value, input, key, visit, addEntity), _babelHelpers$extends)) : output;
      }, {});
    };

    ValuesSchema.prototype.denormalize = function denormalize(input, unvisit) {
      var _this3 = this;

      return Object.keys(input).reduce(function (output, key) {
        var _babelHelpers$extends2;

        var entityOrId = input[key];
        return _extends({}, output, (_babelHelpers$extends2 = {}, _babelHelpers$extends2[key] = _this3.denormalizeValue(entityOrId, unvisit), _babelHelpers$extends2));
      }, {});
    };

    return ValuesSchema;
  }(PolymorphicSchema);

  var validateSchema = function validateSchema(definition) {
    var isArray = Array.isArray(definition);
    if (isArray && definition.length > 1) {
      throw new Error('Expected schema definition to be a single schema, but found ' + definition.length + '.');
    }

    return definition[0];
  };

  var getValues = function getValues(input) {
    return Array.isArray(input) ? input : Object.keys(input).map(function (key) {
      return input[key];
    });
  };

  var normalize = function normalize(schema, input, parent, key, visit, addEntity) {
    schema = validateSchema(schema);

    var values = getValues(input);

    // Special case: Arrays pass *their* parent on to their children, since there
    // is not any special information that can be gathered from themselves directly
    return values.map(function (value, index) {
      return visit(value, parent, key, schema, addEntity);
    });
  };

  var denormalize = function denormalize(schema, input, unvisit) {
    schema = validateSchema(schema);
    return input && input.map ? input.map(function (entityOrId) {
      return unvisit(entityOrId, schema);
    }) : input;
  };

  var ArraySchema = function (_PolymorphicSchema) {
    inherits(ArraySchema, _PolymorphicSchema);

    function ArraySchema() {
      classCallCheck(this, ArraySchema);
      return possibleConstructorReturn(this, _PolymorphicSchema.apply(this, arguments));
    }

    ArraySchema.prototype.normalize = function normalize(input, parent, key, visit, addEntity) {
      var _this2 = this;

      var values = getValues(input);

      return values.map(function (value, index) {
        return _this2.normalizeValue(value, parent, key, visit, addEntity);
      }).filter(function (value) {
        return value !== undefined && value !== null;
      });
    };

    ArraySchema.prototype.denormalize = function denormalize(input, unvisit) {
      var _this3 = this;

      return input && input.map ? input.map(function (value) {
        return _this3.denormalizeValue(value, unvisit);
      }) : input;
    };

    return ArraySchema;
  }(PolymorphicSchema);

  var _normalize = function _normalize(schema, input, parent, key, visit, addEntity) {
    var object = _extends({}, input);
    Object.keys(schema).forEach(function (key) {
      var localSchema = schema[key];
      var value = visit(input[key], input, key, localSchema, addEntity);
      if (value === undefined || value === null) {
        delete object[key];
      } else {
        object[key] = value;
      }
    });
    return object;
  };

  var _denormalize = function _denormalize(schema, input, unvisit) {
    if (isImmutable(input)) {
      return denormalizeImmutable(schema, input, unvisit);
    }

    var object = _extends({}, input);
    Object.keys(schema).forEach(function (key) {
      if (object[key]) {
        object[key] = unvisit(object[key], schema[key]);
      }
    });
    return object;
  };

  var ObjectSchema = function () {
    function ObjectSchema(definition) {
      classCallCheck(this, ObjectSchema);

      this.define(definition);
    }

    ObjectSchema.prototype.define = function define(definition) {
      this.schema = Object.keys(definition).reduce(function (entitySchema, key) {
        var _babelHelpers$extends;

        var schema = definition[key];
        return _extends({}, entitySchema, (_babelHelpers$extends = {}, _babelHelpers$extends[key] = schema, _babelHelpers$extends));
      }, this.schema || {});
    };

    ObjectSchema.prototype.normalize = function normalize() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _normalize.apply(undefined, [this.schema].concat(args));
    };

    ObjectSchema.prototype.denormalize = function denormalize() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return _denormalize.apply(undefined, [this.schema].concat(args));
    };

    return ObjectSchema;
  }();

  var visit = function visit(value, parent, key, schema, addEntity) {
    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' || !value) {
      return value;
    }

    if ((typeof schema === 'undefined' ? 'undefined' : _typeof(schema)) === 'object' && (!schema.normalize || typeof schema.normalize !== 'function')) {
      var method = Array.isArray(schema) ? normalize : _normalize;
      return method(schema, value, parent, key, visit, addEntity);
    }

    return schema.normalize(value, parent, key, visit, addEntity);
  };

  var addEntities = function addEntities(entities) {
    return function (schema, processedEntity, value, parent, key) {
      var schemaKey = schema.key;
      var id = schema.getId(value, parent, key);
      if (!(schemaKey in entities)) {
        entities[schemaKey] = {};
      }

      var existingEntity = entities[schemaKey][id];
      if (existingEntity) {
        entities[schemaKey][id] = schema.merge(existingEntity, processedEntity);
      } else {
        entities[schemaKey][id] = processedEntity;
      }
    };
  };

  var schema = {
    Array: ArraySchema,
    Entity: EntitySchema,
    Object: ObjectSchema,
    Union: UnionSchema,
    Values: ValuesSchema
  };

  var normalize$1 = function normalize$$1(input, schema) {
    if (!input || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object') {
      throw new Error('Unexpected input given to normalize. Expected type to be "object", found "' + (typeof input === 'undefined' ? 'undefined' : _typeof(input)) + '".');
    }

    var entities = {};
    var addEntity = addEntities(entities);

    var result = visit(input, input, null, schema, addEntity);
    return { entities: entities, result: result };
  };

  var unvisitEntity = function unvisitEntity(id, schema, unvisit, getEntity, cache) {
    var entity = getEntity(id, schema);
    if ((typeof entity === 'undefined' ? 'undefined' : _typeof(entity)) !== 'object' || entity === null) {
      return entity;
    }

    if (!cache[schema.key]) {
      cache[schema.key] = {};
    }

    if (!cache[schema.key][id]) {
      // Ensure we don't mutate it non-immutable objects
      var entityCopy = isImmutable(entity) ? entity : _extends({}, entity);

      // Need to set this first so that if it is referenced further within the
      // denormalization the reference will already exist.
      cache[schema.key][id] = entityCopy;
      cache[schema.key][id] = schema.denormalize(entityCopy, unvisit);
    }

    return cache[schema.key][id];
  };

  var getUnvisit = function getUnvisit(entities) {
    var cache = {};
    var getEntity = getEntities(entities);

    return function unvisit(input, schema) {
      if ((typeof schema === 'undefined' ? 'undefined' : _typeof(schema)) === 'object' && (!schema.denormalize || typeof schema.denormalize !== 'function')) {
        var method = Array.isArray(schema) ? denormalize : _denormalize;
        return method(schema, input, unvisit);
      }

      if (input === undefined || input === null) {
        return input;
      }

      if (schema instanceof EntitySchema) {
        return unvisitEntity(input, schema, unvisit, getEntity, cache);
      }

      return schema.denormalize(input, unvisit);
    };
  };

  var getEntities = function getEntities(entities) {
    var isImmutable$$1 = isImmutable(entities);

    return function (entityOrId, schema) {
      var schemaKey = schema.key;

      if ((typeof entityOrId === 'undefined' ? 'undefined' : _typeof(entityOrId)) === 'object') {
        return entityOrId;
      }

      return isImmutable$$1 ? entities.getIn([schemaKey, entityOrId.toString()]) : entities[schemaKey][entityOrId];
    };
  };

  var denormalize$1 = function denormalize$$1(input, schema, entities) {
    if (typeof input !== 'undefined') {
      return getUnvisit(entities)(input, schema);
    }
  };

  var ConfigManager =
  /*#__PURE__*/
  function () {
    function ConfigManager(configs) {
      var _this = this;

      if (configs === void 0) {
        configs = [];
      }

      this.configs = [];
      configs.forEach(function (config) {
        _this.add(config);
      });
    }

    var _proto = ConfigManager.prototype;

    _proto.add = function add(config) {
      if (!config || !config.isConfig() || !config.name()) {
        throw new TypeError('ConfigManager(add): `config` must be a Config instance.');
      }

      if (this.configs.find(function (c) {
        return c.name() === config.name();
      })) {
        throw new Error("ConfigManager(add): config '" + config.name() + "' already exists");
      }

      this.configs.push(config);
    };

    _proto.merge = function merge() {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      var initialValue = values.reduce(function (acc, value) {
        return value && typeof value === 'object' ? _objectSpread({}, acc, value) : acc;
      }, {});
      return this.configs.reduce(function (acc, config) {
        var name = config.name();
        acc[name] = config.merge.apply(config, values.map(function (value) {
          if (value === void 0) {
            value = {};
          }

          return value[name];
        }));
        return acc;
      }, initialValue);
    };

    _proto.set = function set(value) {
      if (value === void 0) {
        value = {};
      }

      var initialValue = value && typeof value === 'object' ? _objectSpread({}, value) : {};
      return this.configs.reduce(function (acc, config) {
        var name = config.name();
        acc[name] = config.set(value[name]);
        return acc;
      }, initialValue);
    };

    return ConfigManager;
  }();

  /**
   * @summary Use to namespacing route
   * @export
   * @function prefix
   * @param {String} base
   * @param {String} [prefix]
   * @param {String} [separator='']
   */
  var prefix = (function (base, prefix, separator) {
    if (separator === void 0) {
      separator = '';
    }

    if (!prefix) return base;
    return !base || base === 'index' ? prefix : "" + prefix + separator + base;
  });

  var identity = function identity(i) {
    return i;
  };
  /**
   * @class RouteConfig
   * @export
   */


  var RouteConfig =
  /*#__PURE__*/
  function () {
    /**
     * @summary Creates an instance of RouteDescriptor.
     * @locus Anywhere
     * @memberof RouteConfig
     * @param {Object} [map={ namespaces:{}, routes: {} }]
     * @param {Object} [options={}]
     * @param {ConfigManager} [options.configs]
     */
    function RouteConfig(map, options) {
      if (options === void 0) {
        options = {};
      }

      this.configManager = new ConfigManager(options.configs);
      this.keys = {
        namespaces: [],
        routes: []
      };
      this.namespaces = {};
      this.options = options;
      this.routes = {};

      this._initMap(map || {
        namespaces: {},
        routes: {}
      });
    }

    var _proto = RouteConfig.prototype;

    _proto._cloneAttributes = function _cloneAttributes(source) {
      if (source === void 0) {
        source = this;
      }

      if (!source) return source;
      var attributes = ['fullPath', 'id', 'key', 'path'];
      var clone = {};

      if (source.config) {
        clone.config = this.configManager.set(source.config);
      }

      return attributes.reduce(function (acc, attributeName) {
        if (source[attributeName]) {
          acc[attributeName] = source[attributeName];
        }

        return acc;
      }, clone);
    }
    /**
     * @summary Returns `key` route
     * @locus Anywhere
     * @memberof RouteConfig
     * @method _findRoute
     * @param {Array<String>|String} key
     * @private
     * @return {Object}
     */
    ;

    _proto._findRoute = function _findRoute(key) {
      var keys = Array.isArray(key) ? key : key.split('.');
      var route;

      if (keys.length === 1) {
        route = this.routes[key] || this.namespaces[key] && this.namespaces[key]._findRoute('index');
      } else if (keys.length > 1) {
        route = this.namespaces[keys[0]] && this.namespaces[keys[0]]._findRoute(keys.slice(1));
      }

      if (!route && "development" === 'development') {
        // eslint-disable-next-line
        console.warn("RouteConfig: Route(" + key + ") not found");
      }

      return route;
    }
    /**
     * @summary Returns map can be normalized
     * @locus Anywhere
     * @instance
     * @memberof RouteConfig
     * @method _getNormalizableMap
     * @param {Object} [options={}]
     * @param {Function} [options.filter]
     * @param {Function} [options.formatRoute=identity]
     * @private
     * @return {Object}
     */
    ;

    _proto._getNormalizableMap = function _getNormalizableMap(options) {
      var _this = this;

      if (options === void 0) {
        options = {};
      }

      var _options = options,
          filter = _options.filter,
          _options$formatRoute = _options.formatRoute,
          formatRoute = _options$formatRoute === void 0 ? identity : _options$formatRoute;

      var map = this._cloneAttributes();

      map.namespaces = [];
      map.routes = [];
      this.keys.namespaces.forEach(function (nKey) {
        if (filter && !filter(_this.namespaces[nKey])) return;

        var namespace = _this.namespaces[nKey]._getNormalizableMap(options);

        if (namespace) {
          map.namespaces.push(namespace);
        }
      });
      this.keys.routes.forEach(function (rKey) {
        if (filter && !filter(_this.routes[rKey])) return;
        map.routes.push(formatRoute(_this._cloneAttributes(_this.routes[rKey])));
      });
      return map.namespaces.length > 0 || map.routes.length > 0 ? map : null;
    }
    /**
     * @summary Init map from `map`
     * @locus Anywhere
     * @instance
     * @memberof RouteConfig
     * @method _initMap
     * @param {Object} map
     * @private
     */
    ;

    _proto._initMap = function _initMap(map) {
      var _this2 = this;

      if (!map) {
        throw new Error('RouteConfig: `map` is required.');
      }

      var _map$namespaces = map.namespaces,
          namespaces = _map$namespaces === void 0 ? {} : _map$namespaces,
          _map$routes = map.routes,
          routes = _map$routes === void 0 ? {} : _map$routes;

      var values = this._cloneAttributes(map);

      Object.keys(values).forEach(function (value) {
        if (values[value]) {
          _this2[value] = values[value];
        }
      });
      Object.keys(namespaces).forEach(function (key) {
        _this2.namespace(_objectSpread({
          key: key
        }, namespaces[key]));
      });
      Object.keys(routes).forEach(function (key) {
        _this2.route(_objectSpread({
          key: key
        }, routes[key]));
      });
    }
    /**
     * @summary Returns map namespaces and routes
     * @locus Anywhere
     * @instance
     * @memberof RouteConfig
     * @method getMap
     * @param {Object} [options={}]
     * @param {Function} [options.filter]
     * @param {Function} [options.formatRoute=identity]
     * @return {Object}
     * @throws {TypeError}
     */
    ;

    _proto.getMap = function getMap(options) {
      var _this3 = this;

      if (options === void 0) {
        options = {};
      }

      var _options2 = options,
          filter = _options2.filter,
          _options2$formatRoute = _options2.formatRoute,
          formatRoute = _options2$formatRoute === void 0 ? identity : _options2$formatRoute;
      var namespaceSize = 0;
      var routeSize = 0;

      var map = _objectSpread({}, this._cloneAttributes(), {
        namespaces: this.keys.namespaces.reduce(function (acc, nKey) {
          if (filter && !filter(_this3.namespaces[nKey])) return acc;

          var namespace = _this3.namespaces[nKey].getMap(options);

          if (namespace) {
            acc[nKey] = namespace;
            namespaceSize += 1;
          }

          return acc;
        }, {}),
        routes: this.keys.routes.reduce(function (acc, rKey) {
          if (!filter || filter(_this3.routes[rKey])) {
            acc[rKey] = formatRoute(_this3._cloneAttributes(_this3.routes[rKey]));
            routeSize += 1;
          }

          return acc;
        }, {})
      });

      return namespaceSize > 0 || routeSize > 0 ? map : null;
    }
    /**
     * @summary Returns normalized map
     * @locus Anywhere
     * @instance
     * @memberof RouteConfig
     * @method getNormalizedMap
     * @param {Object} [options={}]
     * @param {Function} [options.filter]
     * @param {Function} [options.formatRoute=identity]
     * @return {Object}
     * @throws {AssertionError}
     */
    ;

    _proto.getNormalizedMap = function getNormalizedMap(options) {
      if (options === void 0) {
        options = {};
      }

      var map = this._getNormalizableMap(options);

      if (!map) return null;
      var routeSchema = new schema.Entity('routes');
      var namespaceSchema = new schema.Entity('namespaces', {
        routes: [routeSchema]
      });
      namespaceSchema.define({
        namespaces: [namespaceSchema]
      });
      return normalize$1(map, {
        namespaces: [namespaceSchema],
        routes: [routeSchema]
      });
    }
    /**
     * @summary Returns route by `key`
     * @locus Anywhere
     * @instance
     * @memberof RouteConfig
     * @method getRoute
     * @param {String} key
     * @return {Object}
     * @throws {TypeError}
     */
    ;

    _proto.getRoute = function getRoute(key) {
      if (typeof key !== 'string' || key === '') {
        throw new TypeError('RouteConfig(getRoute): `key` must be a non empty string.');
      }

      return this._cloneAttributes(this._findRoute(key));
    }
    /**
     * @summary Merges maps
     * @locus Anywhere
     * @instance
     * @memberof RouteConfig
     * @method  merge
     * @param {...Object} maps
     */
    ;

    _proto.merge = function merge() {
      var _this4 = this;

      for (var _len = arguments.length, maps = new Array(_len), _key = 0; _key < _len; _key++) {
        maps[_key] = arguments[_key];
      }

      maps.forEach(function (_ref) {
        var config = _ref.config,
            _ref$namespaces = _ref.namespaces,
            namespaces = _ref$namespaces === void 0 ? {} : _ref$namespaces,
            _ref$routes = _ref.routes,
            routes = _ref$routes === void 0 ? {} : _ref$routes,
            other = _objectWithoutPropertiesLoose(_ref, ["config", "namespaces", "routes"]);

        var values = _this4._cloneAttributes(_objectSpread({
          config: config || _this4.config ? _this4.configManager.merge(_this4.config || {}, config || {}) : undefined
        }, other));

        Object.keys(values).forEach(function (value) {
          if (values[value]) {
            _this4[value] = values[value];
          }
        });
        Object.keys(namespaces).forEach(function (name) {
          var namespace = _this4.namespaces[name];

          if (namespace) {
            namespace.merge(namespaces[name]);
          } else {
            _this4.namespace(_objectSpread({}, namespaces[name], {
              key: name
            }));
          }
        });
        Object.keys(routes).forEach(function (name) {
          var route = _this4.routes[name] || {};

          _this4.route(_this4._cloneAttributes(_objectSpread({}, routes[name], {
            key: name,
            config: _this4.configManager.merge(route.config || {}, routes[name].config || {})
          })));
        });
      });
    }
    /**
     * @summary Adds namespace and it's nested namespaces / routes
     * @locus Anywhere
     * @instance
     * @memberof RouteConfig
     * @method namespace
     * @param {String} namespace
     * @param {Object} [namespace.config]
     * @param {String} [namespace.fullPath]
     * @param {String} [namespace.id]
     * @param {String} namespace.key
     * @param {Object} [namespace.namespaces={}]
     * @param {String} namespace.path
     * @param {Object} [namespace.routes={}]
     * @return {RouteConfig}
     * @throws {TypeError}
     */
    ;

    _proto.namespace = function namespace(_ref2) {
      var config = _ref2.config,
          fullPath = _ref2.fullPath,
          id = _ref2.id,
          key = _ref2.key,
          _ref2$namespaces = _ref2.namespaces,
          namespaces = _ref2$namespaces === void 0 ? {} : _ref2$namespaces,
          path = _ref2.path,
          _ref2$routes = _ref2.routes,
          routes = _ref2$routes === void 0 ? {} : _ref2$routes;

      if (fullPath && typeof fullPath !== 'string') {
        throw new TypeError('RouteConfig(namespace): `fullPath` must be a non empty string.');
      }

      if (id && typeof id !== 'string') {
        throw new TypeError('RouteConfig(namespace): `id` must be a non empty string.');
      }

      if (typeof key !== 'string' || key === '') {
        throw new TypeError('RouteConfig(namespace): `key` must be a non empty string.');
      }

      if (typeof path !== 'string' || path === '') {
        throw new TypeError('RouteConfig(namespace): `path` must be a non empty string.');
      }

      this.namespaces[key] = new RouteConfig({
        config: this.configManager.merge(this.config, this.configManager.set(config)),
        fullPath: fullPath || prefix(path, this.fullPath),
        id: id || prefix(key, this.id, '.'),
        key: key,
        namespaces: namespaces,
        path: path,
        routes: routes
      }, this.options);

      if (!this.keys.namespaces.includes(key)) {
        this.keys.namespaces.push(key);
      }

      return this.namespaces[key];
    }
    /**
     * @summary Adds route
     * @locus Anywhere
     * @instance
     * @memberof RouteConfig
     * @method route
     * @param {Object} route
     * @param {Object} [route.config]
     * @param {String} [route.fullPath]
     * @param {String} [route.id]
     * @param {String} route.key
     * @param {String} [route.path]
     * @return {RouteConfig}
     * @throws {TypeError}
     */
    ;

    _proto.route = function route(_ref3) {
      var config = _ref3.config,
          fullPath = _ref3.fullPath,
          id = _ref3.id,
          key = _ref3.key,
          path = _ref3.path;

      if (fullPath && typeof fullPath !== 'string') {
        throw new TypeError('RouteConfig(route): `fullPath` must be a non empty string.');
      }

      if (id && typeof id !== 'string') {
        throw new TypeError('RouteConfig(route): `id` must be a non empty string.');
      }

      if (typeof key !== 'string' || key === '') {
        throw new TypeError('RouteConfig(route): `key` must be a non empty string.');
      }

      if (path && typeof path !== 'string') {
        throw new TypeError('RouteConfig(route): `path` must be a string.');
      }

      var route = {
        config: this.configManager.merge(this.config, this.configManager.set(config)),
        fullPath: fullPath || prefix(path || '', this.fullPath),
        id: id || prefix(key, this.id, '.'),
        key: key
      };

      if (path) {
        route.path = path;
      }

      this.routes[key] = route;

      if (!this.keys.routes.includes(key)) {
        this.keys.routes.push(key);
      }

      return this;
    }
    /**
     * @summary Returns route url for `key`
     * @locus Anywhere
     * @instance
     * @memberof RouteConfig
     * @method url
     * @param {String} [key='index']
     * @param {Object} [params]
     * @param {Object} [options]
     * @return {Null|String}
     */
    ;

    _proto.url = function url(key, params, options) {
      if (key === void 0) {
        key = 'index';
      }

      if (params === void 0) {
        params = undefined;
      }

      if (options === void 0) {
        options = undefined;
      }

      if (typeof key !== 'string' || key === '') {
        throw new TypeError('RouteConfig(url): `key` must be a string.');
      }

      var route = this._findRoute(key);

      if (!route) return null;
      var compiled = pathToRegexp_1.compile(route.fullPath);
      return params || options ? compiled(params, options) : route.fullPath;
    };

    return RouteConfig;
  }();

  RouteConfig.fromNormalizedMap = function (normalizedMap, options) {
    var routeSchema = new schema.Entity('routes');
    var namespaceSchema = new schema.Entity('namespaces', {
      routes: [routeSchema]
    });
    namespaceSchema.define({
      namespaces: [namespaceSchema]
    });
    var normalizableMap = denormalize$1(normalizedMap.result, {
      namespaces: [namespaceSchema],
      routes: [routeSchema]
    }, normalizedMap.entities);

    var normalizableMapToMap = function normalizableMapToMap(nMap) {
      return _objectSpread({}, nMap, {
        namespaces: nMap.namespaces.reduce(function (acc, namespace) {
          acc[namespace.key] = normalizableMapToMap(namespace);
          return acc;
        }, {}),
        routes: nMap.routes.reduce(function (acc, route) {
          acc[route.key] = route;
          return acc;
        }, {})
      });
    };

    return new RouteConfig(normalizableMapToMap(normalizableMap), options);
  };

  exports.Config = Config;
  exports.RouteConfig = RouteConfig;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
