import pathToRegexp from 'path-to-regexp';
import { schema, normalize, denormalize } from 'normalizr';

var Config =
/*#__PURE__*/
function () {
  function Config(name) {
    if (typeof name !== 'string') {
      throw new TypeError('Config: name must be a string');
    }

    this._name = name;
  }

  var _proto = Config.prototype;

  _proto.isConfig = function isConfig() {
    return true;
  };

  _proto.merge = function merge() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }

    return Object.assign.apply(Object, [{}].concat(values));
  };

  _proto.name = function name() {
    return this._name;
  };

  _proto.set = function set(value) {
    return Object.assign({}, value);
  };

  return Config;
}();

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var ConfigManager =
/*#__PURE__*/
function () {
  function ConfigManager(configs) {
    var _this = this;

    if (configs === void 0) {
      configs = [];
    }

    this.configs = [];
    configs.forEach(function (config) {
      _this.add(config);
    });
  }

  var _proto = ConfigManager.prototype;

  _proto.add = function add(config) {
    if (!config || !config.isConfig() || !config.name()) {
      throw new TypeError('ConfigManager(add): `config` must be a Config instance.');
    }

    if (this.configs.find(function (c) {
      return c.name() === config.name();
    })) {
      throw new Error("ConfigManager(add): config '" + config.name() + "' already exists");
    }

    this.configs.push(config);
  };

  _proto.merge = function merge() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }

    var initialValue = values.reduce(function (acc, value) {
      return value && typeof value === 'object' ? _objectSpread({}, acc, value) : acc;
    }, {});
    return this.configs.reduce(function (acc, config) {
      var name = config.name();
      acc[name] = config.merge.apply(config, values.map(function (value) {
        if (value === void 0) {
          value = {};
        }

        return value[name];
      }));
      return acc;
    }, initialValue);
  };

  _proto.set = function set(value) {
    if (value === void 0) {
      value = {};
    }

    var initialValue = value && typeof value === 'object' ? _objectSpread({}, value) : {};
    return this.configs.reduce(function (acc, config) {
      var name = config.name();
      acc[name] = config.set(value[name]);
      return acc;
    }, initialValue);
  };

  return ConfigManager;
}();

/**
 * @summary Use to namespacing route
 * @export
 * @function prefix
 * @param {String} base
 * @param {String} [prefix]
 * @param {String} [separator='']
 */
var prefix = (function (base, prefix, separator) {
  if (separator === void 0) {
    separator = '';
  }

  if (!prefix) return base;
  return !base || base === 'index' ? prefix : "" + prefix + separator + base;
});

var identity = function identity(i) {
  return i;
};
/**
 * @class RouteConfig
 * @export
 */


var RouteConfig =
/*#__PURE__*/
function () {
  /**
   * @summary Creates an instance of RouteDescriptor.
   * @locus Anywhere
   * @memberof RouteConfig
   * @param {Object} [map={ namespaces:{}, routes: {} }]
   * @param {Object} [options={}]
   * @param {ConfigManager} [options.configs]
   */
  function RouteConfig(map, options) {
    if (options === void 0) {
      options = {};
    }

    this.configManager = new ConfigManager(options.configs);
    this.keys = {
      namespaces: [],
      routes: []
    };
    this.namespaces = {};
    this.options = options;
    this.routes = {};

    this._initMap(map || {
      namespaces: {},
      routes: {}
    });
  }

  var _proto = RouteConfig.prototype;

  _proto._cloneAttributes = function _cloneAttributes(source) {
    if (source === void 0) {
      source = this;
    }

    if (!source) return source;
    var attributes = ['fullPath', 'id', 'key', 'path'];
    var clone = {};

    if (source.config) {
      clone.config = this.configManager.set(source.config);
    }

    return attributes.reduce(function (acc, attributeName) {
      if (source[attributeName]) {
        acc[attributeName] = source[attributeName];
      }

      return acc;
    }, clone);
  }
  /**
   * @summary Returns `key` route
   * @locus Anywhere
   * @memberof RouteConfig
   * @method _findRoute
   * @param {Array<String>|String} key
   * @private
   * @return {Object}
   */
  ;

  _proto._findRoute = function _findRoute(key) {
    var keys = Array.isArray(key) ? key : key.split('.');
    var route;

    if (keys.length === 1) {
      route = this.routes[key] || this.namespaces[key] && this.namespaces[key]._findRoute('index');
    } else if (keys.length > 1) {
      route = this.namespaces[keys[0]] && this.namespaces[keys[0]]._findRoute(keys.slice(1));
    }

    if (!route && process.env.NODE_ENV === 'development') {
      // eslint-disable-next-line
      console.warn("RouteConfig: Route(" + key + ") not found");
    }

    return route;
  }
  /**
   * @summary Returns map can be normalized
   * @locus Anywhere
   * @instance
   * @memberof RouteConfig
   * @method _getNormalizableMap
   * @param {Object} [options={}]
   * @param {Function} [options.filter]
   * @param {Function} [options.formatRoute=identity]
   * @private
   * @return {Object}
   */
  ;

  _proto._getNormalizableMap = function _getNormalizableMap(options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    var _options = options,
        filter = _options.filter,
        _options$formatRoute = _options.formatRoute,
        formatRoute = _options$formatRoute === void 0 ? identity : _options$formatRoute;

    var map = this._cloneAttributes();

    map.namespaces = [];
    map.routes = [];
    this.keys.namespaces.forEach(function (nKey) {
      if (filter && !filter(_this.namespaces[nKey])) return;

      var namespace = _this.namespaces[nKey]._getNormalizableMap(options);

      if (namespace) {
        map.namespaces.push(namespace);
      }
    });
    this.keys.routes.forEach(function (rKey) {
      if (filter && !filter(_this.routes[rKey])) return;
      map.routes.push(formatRoute(_this._cloneAttributes(_this.routes[rKey])));
    });
    return map.namespaces.length > 0 || map.routes.length > 0 ? map : null;
  }
  /**
   * @summary Init map from `map`
   * @locus Anywhere
   * @instance
   * @memberof RouteConfig
   * @method _initMap
   * @param {Object} map
   * @private
   */
  ;

  _proto._initMap = function _initMap(map) {
    var _this2 = this;

    if (!map) {
      throw new Error('RouteConfig: `map` is required.');
    }

    var _map$namespaces = map.namespaces,
        namespaces = _map$namespaces === void 0 ? {} : _map$namespaces,
        _map$routes = map.routes,
        routes = _map$routes === void 0 ? {} : _map$routes;

    var values = this._cloneAttributes(map);

    Object.keys(values).forEach(function (value) {
      if (values[value]) {
        _this2[value] = values[value];
      }
    });
    Object.keys(namespaces).forEach(function (key) {
      _this2.namespace(_objectSpread({
        key: key
      }, namespaces[key]));
    });
    Object.keys(routes).forEach(function (key) {
      _this2.route(_objectSpread({
        key: key
      }, routes[key]));
    });
  }
  /**
   * @summary Returns map namespaces and routes
   * @locus Anywhere
   * @instance
   * @memberof RouteConfig
   * @method getMap
   * @param {Object} [options={}]
   * @param {Function} [options.filter]
   * @param {Function} [options.formatRoute=identity]
   * @return {Object}
   * @throws {TypeError}
   */
  ;

  _proto.getMap = function getMap(options) {
    var _this3 = this;

    if (options === void 0) {
      options = {};
    }

    var _options2 = options,
        filter = _options2.filter,
        _options2$formatRoute = _options2.formatRoute,
        formatRoute = _options2$formatRoute === void 0 ? identity : _options2$formatRoute;
    var namespaceSize = 0;
    var routeSize = 0;

    var map = _objectSpread({}, this._cloneAttributes(), {
      namespaces: this.keys.namespaces.reduce(function (acc, nKey) {
        if (filter && !filter(_this3.namespaces[nKey])) return acc;

        var namespace = _this3.namespaces[nKey].getMap(options);

        if (namespace) {
          acc[nKey] = namespace;
          namespaceSize += 1;
        }

        return acc;
      }, {}),
      routes: this.keys.routes.reduce(function (acc, rKey) {
        if (!filter || filter(_this3.routes[rKey])) {
          acc[rKey] = formatRoute(_this3._cloneAttributes(_this3.routes[rKey]));
          routeSize += 1;
        }

        return acc;
      }, {})
    });

    return namespaceSize > 0 || routeSize > 0 ? map : null;
  }
  /**
   * @summary Returns normalized map
   * @locus Anywhere
   * @instance
   * @memberof RouteConfig
   * @method getNormalizedMap
   * @param {Object} [options={}]
   * @param {Function} [options.filter]
   * @param {Function} [options.formatRoute=identity]
   * @return {Object}
   * @throws {AssertionError}
   */
  ;

  _proto.getNormalizedMap = function getNormalizedMap(options) {
    if (options === void 0) {
      options = {};
    }

    var map = this._getNormalizableMap(options);

    if (!map) return null;
    var routeSchema = new schema.Entity('routes');
    var namespaceSchema = new schema.Entity('namespaces', {
      routes: [routeSchema]
    });
    namespaceSchema.define({
      namespaces: [namespaceSchema]
    });
    return normalize(map, {
      namespaces: [namespaceSchema],
      routes: [routeSchema]
    });
  }
  /**
   * @summary Returns route by `key`
   * @locus Anywhere
   * @instance
   * @memberof RouteConfig
   * @method getRoute
   * @param {String} key
   * @return {Object}
   * @throws {TypeError}
   */
  ;

  _proto.getRoute = function getRoute(key) {
    if (typeof key !== 'string' || key === '') {
      throw new TypeError('RouteConfig(getRoute): `key` must be a non empty string.');
    }

    return this._cloneAttributes(this._findRoute(key));
  }
  /**
   * @summary Merges maps
   * @locus Anywhere
   * @instance
   * @memberof RouteConfig
   * @method  merge
   * @param {...Object} maps
   */
  ;

  _proto.merge = function merge() {
    var _this4 = this;

    for (var _len = arguments.length, maps = new Array(_len), _key = 0; _key < _len; _key++) {
      maps[_key] = arguments[_key];
    }

    maps.forEach(function (_ref) {
      var config = _ref.config,
          _ref$namespaces = _ref.namespaces,
          namespaces = _ref$namespaces === void 0 ? {} : _ref$namespaces,
          _ref$routes = _ref.routes,
          routes = _ref$routes === void 0 ? {} : _ref$routes,
          other = _objectWithoutPropertiesLoose(_ref, ["config", "namespaces", "routes"]);

      var values = _this4._cloneAttributes(_objectSpread({
        config: config || _this4.config ? _this4.configManager.merge(_this4.config || {}, config || {}) : undefined
      }, other));

      Object.keys(values).forEach(function (value) {
        if (values[value]) {
          _this4[value] = values[value];
        }
      });
      Object.keys(namespaces).forEach(function (name) {
        var namespace = _this4.namespaces[name];

        if (namespace) {
          namespace.merge(namespaces[name]);
        } else {
          _this4.namespace(_objectSpread({}, namespaces[name], {
            key: name
          }));
        }
      });
      Object.keys(routes).forEach(function (name) {
        var route = _this4.routes[name] || {};

        _this4.route(_this4._cloneAttributes(_objectSpread({}, routes[name], {
          key: name,
          config: _this4.configManager.merge(route.config || {}, routes[name].config || {})
        })));
      });
    });
  }
  /**
   * @summary Adds namespace and it's nested namespaces / routes
   * @locus Anywhere
   * @instance
   * @memberof RouteConfig
   * @method namespace
   * @param {String} namespace
   * @param {Object} [namespace.config]
   * @param {String} [namespace.fullPath]
   * @param {String} [namespace.id]
   * @param {String} namespace.key
   * @param {Object} [namespace.namespaces={}]
   * @param {String} namespace.path
   * @param {Object} [namespace.routes={}]
   * @return {RouteConfig}
   * @throws {TypeError}
   */
  ;

  _proto.namespace = function namespace(_ref2) {
    var config = _ref2.config,
        fullPath = _ref2.fullPath,
        id = _ref2.id,
        key = _ref2.key,
        _ref2$namespaces = _ref2.namespaces,
        namespaces = _ref2$namespaces === void 0 ? {} : _ref2$namespaces,
        path = _ref2.path,
        _ref2$routes = _ref2.routes,
        routes = _ref2$routes === void 0 ? {} : _ref2$routes;

    if (fullPath && typeof fullPath !== 'string') {
      throw new TypeError('RouteConfig(namespace): `fullPath` must be a non empty string.');
    }

    if (id && typeof id !== 'string') {
      throw new TypeError('RouteConfig(namespace): `id` must be a non empty string.');
    }

    if (typeof key !== 'string' || key === '') {
      throw new TypeError('RouteConfig(namespace): `key` must be a non empty string.');
    }

    if (typeof path !== 'string' || path === '') {
      throw new TypeError('RouteConfig(namespace): `path` must be a non empty string.');
    }

    this.namespaces[key] = new RouteConfig({
      config: this.configManager.merge(this.config, this.configManager.set(config)),
      fullPath: fullPath || prefix(path, this.fullPath),
      id: id || prefix(key, this.id, '.'),
      key: key,
      namespaces: namespaces,
      path: path,
      routes: routes
    }, this.options);

    if (!this.keys.namespaces.includes(key)) {
      this.keys.namespaces.push(key);
    }

    return this.namespaces[key];
  }
  /**
   * @summary Adds route
   * @locus Anywhere
   * @instance
   * @memberof RouteConfig
   * @method route
   * @param {Object} route
   * @param {Object} [route.config]
   * @param {String} [route.fullPath]
   * @param {String} [route.id]
   * @param {String} route.key
   * @param {String} [route.path]
   * @return {RouteConfig}
   * @throws {TypeError}
   */
  ;

  _proto.route = function route(_ref3) {
    var config = _ref3.config,
        fullPath = _ref3.fullPath,
        id = _ref3.id,
        key = _ref3.key,
        path = _ref3.path;

    if (fullPath && typeof fullPath !== 'string') {
      throw new TypeError('RouteConfig(route): `fullPath` must be a non empty string.');
    }

    if (id && typeof id !== 'string') {
      throw new TypeError('RouteConfig(route): `id` must be a non empty string.');
    }

    if (typeof key !== 'string' || key === '') {
      throw new TypeError('RouteConfig(route): `key` must be a non empty string.');
    }

    if (path && typeof path !== 'string') {
      throw new TypeError('RouteConfig(route): `path` must be a string.');
    }

    var route = {
      config: this.configManager.merge(this.config, this.configManager.set(config)),
      fullPath: fullPath || prefix(path || '', this.fullPath),
      id: id || prefix(key, this.id, '.'),
      key: key
    };

    if (path) {
      route.path = path;
    }

    this.routes[key] = route;

    if (!this.keys.routes.includes(key)) {
      this.keys.routes.push(key);
    }

    return this;
  }
  /**
   * @summary Returns route url for `key`
   * @locus Anywhere
   * @instance
   * @memberof RouteConfig
   * @method url
   * @param {String} [key='index']
   * @param {Object} [params]
   * @param {Object} [options]
   * @return {Null|String}
   */
  ;

  _proto.url = function url(key, params, options) {
    if (key === void 0) {
      key = 'index';
    }

    if (params === void 0) {
      params = undefined;
    }

    if (options === void 0) {
      options = undefined;
    }

    if (typeof key !== 'string' || key === '') {
      throw new TypeError('RouteConfig(url): `key` must be a string.');
    }

    var route = this._findRoute(key);

    if (!route) return null;
    var compiled = pathToRegexp.compile(route.fullPath);
    return params || options ? compiled(params, options) : route.fullPath;
  };

  return RouteConfig;
}();

RouteConfig.fromNormalizedMap = function (normalizedMap, options) {
  var routeSchema = new schema.Entity('routes');
  var namespaceSchema = new schema.Entity('namespaces', {
    routes: [routeSchema]
  });
  namespaceSchema.define({
    namespaces: [namespaceSchema]
  });
  var normalizableMap = denormalize(normalizedMap.result, {
    namespaces: [namespaceSchema],
    routes: [routeSchema]
  }, normalizedMap.entities);

  var normalizableMapToMap = function normalizableMapToMap(nMap) {
    return _objectSpread({}, nMap, {
      namespaces: nMap.namespaces.reduce(function (acc, namespace) {
        acc[namespace.key] = normalizableMapToMap(namespace);
        return acc;
      }, {}),
      routes: nMap.routes.reduce(function (acc, route) {
        acc[route.key] = route;
        return acc;
      }, {})
    });
  };

  return new RouteConfig(normalizableMapToMap(normalizableMap), options);
};

export { Config, RouteConfig };
